use std::fmt;

use crossbeam_channel::{Receiver, unbounded};
use tray_icon::{
    ClickType, Icon, TrayIcon, TrayIconBuilder, TrayIconEvent,
    menu::{Menu, MenuItem},
};

/// High-level events generated by tray interactions.
///
/// These are the *semantic* actions the tray can ask the app to perform,
/// regardless of which underlying platform or library is used.
#[derive(Debug, Clone)]
pub enum TrayEvent {
    /// User activated the tray item in a way that should toggle visibility
    /// of the main window (e.g., left-click on the icon).
    ToggleWindow,

    /// Explicit request to show the main window.
    ShowWindow,

    /// Explicit request to hide the main window.
    HideWindow,

    /// User clicked "Quit" (or equivalent) in the tray menu.
    QuitRequested,
}

impl fmt::Display for TrayEvent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TrayEvent::ToggleWindow => write!(f, "ToggleWindow"),
            TrayEvent::ShowWindow => write!(f, "ShowWindow"),
            TrayEvent::HideWindow => write!(f, "HideWindow"),
            TrayEvent::QuitRequested => write!(f, "QuitRequested"),
        }
    }
}

/// Configuration for the tray icon and its behavior.
///
/// This is deliberately minimal at first. Over time we can extend it with:
/// - Custom icon paths or theme-aware variants
/// - Tooltip text
/// - Menu structure (favorites, tail options, etc.)
#[derive(Debug, Clone)]
pub struct TrayConfig {
    /// Human-friendly tooltip/title for the tray icon.
    pub tooltip: String,
}

impl Default for TrayConfig {
    fn default() -> Self {
        Self {
            tooltip: "Lumberjack Axe".to_string(),
        }
    }
}

pub struct TrayHandle {
    inner: Option<TrayIcon>,
}

impl TrayHandle {
    pub fn spawn(config: TrayConfig) -> Result<(Self, TrayEventReceiver), TrayError> {
        // Channel from the tray callback to the rest of the app.
        let (sender, receiver) = unbounded::<TrayEvent>();

        // Minimal context menu for now: just a Quit item for future use.
        let menu = Menu::new();
        let _ = MenuItem::new("Quit", true, None);

        let mut builder = TrayIconBuilder::new();
        builder = builder.with_tooltip(config.tooltip);
        builder = builder.with_menu(Box::new(menu));

        if let Some(icon) = load_axe_icon() {
            builder = builder.with_icon(icon);
        }

        tray_icon::TrayIconEvent::set_event_handler(Some(Box::new(move |event: TrayIconEvent| {
            if event.click_type == ClickType::Left {
                let _ = sender.send(TrayEvent::ToggleWindow);
            }
        })));

        let icon = builder
            .build()
            .map_err(|e| TrayError::InitFailed(e.to_string()))?;

        let handle = TrayHandle { inner: Some(icon) };
        let receiver = TrayEventReceiver::new(receiver);

        Ok((handle, receiver))
    }

    /// Construct a dummy handle used when tray initialization fails.
    ///
    /// This allows the rest of the application to keep running without a
    /// functional tray icon.
    pub fn dummy() -> Self {
        TrayHandle { inner: None }
    }

    /// Update the tooltip shown when hovering over the tray icon.
    pub fn set_tooltip(&self, tooltip: &str) {
        // `tray-icon` allows updating properties via its APIs; for now we
        // rebuild the tooltip through the builder if needed in the future.
        // Placeholder: no-op until we decide on a consistent strategy.
        let _ = tooltip;
    }

    /// Update an "unread errors" badge or similar visual indicator on the tray icon.
    ///
    /// The exact appearance of such a badge is platform- and library-dependent,
    /// so the method is intentionally generic. Callers simply express the
    /// count, and the implementation decides how to represent it (or ignore it).
    pub fn set_error_count(&self, _count: u32) {
        // TODO: implement once we decide how to visually represent counts per platform.
    }
}

/// Simple error type for tray initialization and runtime failures.
///
/// This keeps errors from the tray layer distinct from the rest of the app.
#[derive(Debug)]
pub enum TrayError {
    /// Platform or library does not support tray icons in the current context.
    Unsupported,

    /// Generic initialization error, with a human-readable reason.
    InitFailed(String),
}

impl fmt::Display for TrayError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TrayError::Unsupported => write!(f, "tray not supported on this platform"),
            TrayError::InitFailed(reason) => {
                write!(f, "failed to initialize tray: {reason}")
            }
        }
    }
}

impl std::error::Error for TrayError {}

/// Receiver for tray events.
///
/// This is intentionally lightweight and API-shaped like a simple channel
/// receiver so it can be polled from the egui update loop without introducing
/// a hard dependency on any particular async runtime.
#[derive(Debug)]
pub struct TrayEventReceiver {
    inner: Option<Receiver<TrayEvent>>,
}

impl TrayEventReceiver {
    /// Create a new receiver wrapping the given channel.
    pub fn new(inner: Receiver<TrayEvent>) -> Self {
        Self { inner: Some(inner) }
    }

    /// Create an already-closed receiver.
    pub fn closed() -> Self {
        Self { inner: None }
    }

    /// Try to receive the next `TrayEvent`, if any.
    ///
    /// This performs a non-blocking `try_recv` on the underlying channel.
    pub fn try_recv(&mut self) -> Option<TrayEvent> {
        match &self.inner {
            Some(rx) => rx.try_recv().ok(),
            None => None,
        }
    }

    /// Whether this receiver is closed and will never yield further events.
    pub fn is_closed(&self) -> bool {
        self.inner.is_none()
    }
}

fn load_axe_icon() -> Option<Icon> {
    let path = "assets/axe.png";
    match image::open(path) {
        Ok(img) => {
            // Resize to a small square icon for the tray.
            let img = img
                .resize_exact(32, 32, image::imageops::Lanczos3)
                .into_rgba8();
            let (width, height) = img.dimensions();
            let rgba = img.into_raw();

            match Icon::from_rgba(rgba, width, height) {
                Ok(icon) => {
                    println!("[axe] Loaded tray icon from {path} ({width}x{height})");
                    Some(icon)
                }
                Err(e) => {
                    eprintln!("[axe] Failed to create Icon from {path}: {e}");
                    None
                }
            }
        }
        Err(e) => {
            eprintln!("[axe] Failed to open tray icon at {path}: {e}");
            None
        }
    }
}
