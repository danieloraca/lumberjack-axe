//! Tray (system status bar) integration for Lumberjack Axe.
//!
//! The goal of this module is to encapsulate all platform-specific logic
//! required to show a tray / menu bar icon (the "axe") and to coordinate
//! with the main egui/eframe window.
//!
//! It uses the `tray-icon` crate under the hood to create a system tray icon
//! with a basic left-click handler that emits high-level events over a
//! non-blocking crossbeam channel.
//!
//! Design goals:
//! - Keep the rest of the app unaware of the tray crate being used.
//! - Allow the tray to send high-level events (ShowWindow, HideWindow, Quit).
//! - Allow the app to update tray state (e.g., unread error badge) without
//!   talking to platform APIs directly.
//!
//! Over time we can add:
//! - Platform-specific icon variants
//! - Context menus for favorites, quick actions, etc.
//! - Badge/status indicators
//!
//! Example of how this module might be used in `main.rs`:
//! ```ignore
//! let (tray, tray_events) = tray::TrayHandle::spawn(TrayConfig::default())?;
//! // Pass `tray_events` into the egui app loop so UI can react to clicks.
//! // Keep `tray` around to update tooltip, icon badge, etc.
//! ```

use std::fmt;

use crossbeam_channel::{Receiver, unbounded};
use tray_icon::{
    ClickType, TrayIcon, TrayIconBuilder, TrayIconEvent,
    menu::{Menu, MenuItem},
};

/// High-level events generated by tray interactions.
///
/// These are the *semantic* actions the tray can ask the app to perform,
/// regardless of which underlying platform or library is used.
#[derive(Debug, Clone)]
pub enum TrayEvent {
    /// User activated the tray item in a way that should toggle visibility
    /// of the main window (e.g., left-click on the icon).
    ToggleWindow,

    /// Explicit request to show the main window.
    ShowWindow,

    /// Explicit request to hide the main window.
    HideWindow,

    /// User clicked "Quit" (or equivalent) in the tray menu.
    QuitRequested,
}

impl fmt::Display for TrayEvent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TrayEvent::ToggleWindow => write!(f, "ToggleWindow"),
            TrayEvent::ShowWindow => write!(f, "ShowWindow"),
            TrayEvent::HideWindow => write!(f, "HideWindow"),
            TrayEvent::QuitRequested => write!(f, "QuitRequested"),
        }
    }
}

/// Configuration for the tray icon and its behavior.
///
/// This is deliberately minimal at first. Over time we can extend it with:
/// - Custom icon paths or theme-aware variants
/// - Tooltip text
/// - Menu structure (favorites, tail options, etc.)
#[derive(Debug, Clone)]
pub struct TrayConfig {
    /// Human-friendly tooltip/title for the tray icon.
    pub tooltip: String,
}

impl Default for TrayConfig {
    fn default() -> Self {
        Self {
            tooltip: "Lumberjack Axe".to_string(),
        }
    }
}

/// Handle to an active tray instance.
///
/// This owns the underlying `tray-icon` handle for the system tray and
/// provides a small, app-friendly API on top of it.
pub struct TrayHandle {
    inner: Option<TrayIcon>,
}

impl TrayHandle {
    /// Create a new tray instance with the given configuration.
    ///
    /// This:
    /// - Initializes the system tray icon using `tray-icon`
    /// - Sets up a left-click handler that toggles the main window
    /// - Returns a `TrayHandle` plus a non-blocking receiver for `TrayEvent`s
    pub fn spawn(config: TrayConfig) -> Result<(Self, TrayEventReceiver), TrayError> {
        // Channel from the tray callback to the rest of the app.
        let (sender, receiver) = unbounded::<TrayEvent>();

        // Minimal context menu for now: just a Quit item for future use.
        let menu = Menu::new();
        let _ = MenuItem::new("Quit", true, None);

        let mut builder = TrayIconBuilder::new();
        builder = builder.with_tooltip(config.tooltip);
        builder = builder.with_menu(Box::new(menu));

        // Use the global tray icon event hook from tray-icon 0.10.
        tray_icon::TrayIconEvent::set_event_handler(Some(Box::new(move |event: TrayIconEvent| {
            // Left-click on the tray icon should toggle the window.
            if event.click_type == ClickType::Left {
                let _ = sender.send(TrayEvent::ToggleWindow);
            }
        })));

        let icon = builder
            .build()
            .map_err(|e| TrayError::InitFailed(e.to_string()))?;

        let handle = TrayHandle { inner: Some(icon) };
        let receiver = TrayEventReceiver::new(receiver);

        Ok((handle, receiver))
    }

    /// Construct a dummy handle used when tray initialization fails.
    ///
    /// This allows the rest of the application to keep running without a
    /// functional tray icon.
    pub fn dummy() -> Self {
        TrayHandle { inner: None }
    }

    /// Update the tooltip shown when hovering over the tray icon.
    pub fn set_tooltip(&self, tooltip: &str) {
        // `tray-icon` allows updating properties via its APIs; for now we
        // rebuild the tooltip through the builder if needed in the future.
        // Placeholder: no-op until we decide on a consistent strategy.
        let _ = tooltip;
    }

    /// Update an "unread errors" badge or similar visual indicator on the tray icon.
    ///
    /// The exact appearance of such a badge is platform- and library-dependent,
    /// so the method is intentionally generic. Callers simply express the
    /// count, and the implementation decides how to represent it (or ignore it).
    pub fn set_error_count(&self, _count: u32) {
        // TODO: implement once we decide how to visually represent counts per platform.
    }
}

/// Simple error type for tray initialization and runtime failures.
///
/// This keeps errors from the tray layer distinct from the rest of the app.
#[derive(Debug)]
pub enum TrayError {
    /// Platform or library does not support tray icons in the current context.
    Unsupported,

    /// Generic initialization error, with a human-readable reason.
    InitFailed(String),
}

impl fmt::Display for TrayError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TrayError::Unsupported => write!(f, "tray not supported on this platform"),
            TrayError::InitFailed(reason) => {
                write!(f, "failed to initialize tray: {reason}")
            }
        }
    }
}

impl std::error::Error for TrayError {}

/// Receiver for tray events.
///
/// This is intentionally lightweight and API-shaped like a simple channel
/// receiver so it can be polled from the egui update loop without introducing
/// a hard dependency on any particular async runtime.
#[derive(Debug)]
pub struct TrayEventReceiver {
    inner: Option<Receiver<TrayEvent>>,
}

impl TrayEventReceiver {
    /// Create a new receiver wrapping the given channel.
    pub fn new(inner: Receiver<TrayEvent>) -> Self {
        Self { inner: Some(inner) }
    }

    /// Create an already-closed receiver.
    pub fn closed() -> Self {
        Self { inner: None }
    }

    /// Try to receive the next `TrayEvent`, if any.
    ///
    /// This performs a non-blocking `try_recv` on the underlying channel.
    pub fn try_recv(&mut self) -> Option<TrayEvent> {
        match &self.inner {
            Some(rx) => rx.try_recv().ok(),
            None => None,
        }
    }

    /// Whether this receiver is closed and will never yield further events.
    pub fn is_closed(&self) -> bool {
        self.inner.is_none()
    }
}
